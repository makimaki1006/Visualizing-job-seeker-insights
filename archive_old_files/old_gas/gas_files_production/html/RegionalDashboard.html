<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <title>地域別ダッシュボード</title>
    <style>
      :root {
        --bg: #f5f7fb;
        --surface: #ffffff;
        --primary: #1a73e8;
        --primary-light: #e8f0fe;
        --border: #dfe4ea;
        --text: #202124;
        --muted: #5f6368;
        --warn: #c5221f;
        --accent: #34a853;
      }

      html,
      body {
        margin: 0;
        padding: 0;
        background: var(--bg);
        color: var(--text);
        font-family: "Segoe UI", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 32px 24px 48px;
      }

      h1 {
        margin: 0;
        font-size: 26px;
        font-weight: 600;
      }

      .description {
        margin-top: 6px;
        color: var(--muted);
      }

      .region-controls {
        margin-top: 28px;
        display: grid;
        grid-template-columns: 1fr 1fr auto;
        gap: 12px;
        align-items: end;
      }

      .field {
        display: flex;
        flex-direction: column;
        gap: 4px;
      }

      label {
        font-size: 13px;
        color: var(--muted);
      }

      select {
        height: 40px;
        border-radius: 8px;
        border: 1px solid var(--border);
        padding: 0 12px;
        font-size: 14px;
        background: var(--surface);
        transition: border 0.2s ease;
      }

      select:focus {
        border-color: var(--primary);
        outline: none;
      }

      button.primary {
        height: 40px;
        min-width: 120px;
        border: none;
        border-radius: 8px;
        background: var(--primary);
        color: #fff;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: background 0.2s ease;
      }

      button.primary:disabled {
        background: #aac7f6;
        cursor: default;
      }

      button.primary:hover:not(:disabled) {
        background: #1557b0;
      }

      .tabs {
        margin-top: 32px;
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }

      .tab-button {
        padding: 10px 18px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: var(--surface);
        color: var(--muted);
        font-size: 13px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
      }

      .tab-button.active {
        background: var(--primary);
        border-color: var(--primary);
        color: #fff;
        box-shadow: 0 6px 16px rgba(26, 115, 232, 0.25);
      }

      .tab-button:disabled {
        opacity: 0.7;
        cursor: default;
      }

      .panel {
        margin-top: 24px;
        padding: 24px;
        border-radius: 16px;
        background: var(--surface);
        box-shadow: 0 12px 24px rgba(32, 33, 36, 0.08);
      }

      .filters {
        margin-bottom: 12px;
        display: none;
        gap: 12px;
        flex-wrap: wrap;
      }

      .filters.active {
        display: flex;
      }

      .filters select {
        min-width: 220px;
      }

      .summary-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
        gap: 16px;
      }

      .summary-card {
        padding: 18px;
        border-radius: 14px;
        background: var(--primary-light);
        border: 1px solid #d2e3fc;
        display: flex;
        flex-direction: column;
        gap: 6px;
      }

      .summary-card .label {
        font-size: 12px;
        color: var(--muted);
        text-transform: uppercase;
        letter-spacing: 0.08em;
      }

      .summary-card .value {
        font-size: 20px;
        font-weight: 700;
        color: var(--primary);
      }

      .summary-card .note {
        font-size: 12px;
        color: var(--muted);
      }

      .warnings {
        margin-top: 24px;
        padding: 16px 20px;
        border-radius: 12px;
        border: 1px solid rgba(197, 34, 31, 0.35);
        background: rgba(197, 34, 31, 0.08);
        color: var(--warn);
        display: none;
        gap: 8px;
        flex-direction: column;
      }

      .warnings.visible {
        display: flex;
      }

      .warning-title {
        font-weight: 600;
      }

      .table-group {
        margin-top: 28px;
      }

      .table-title {
        font-size: 16px;
        font-weight: 600;
        margin-bottom: 12px;
        display: flex;
        align-items: center;
        gap: 8px;
      }

      table {
        width: 100%;
        border-collapse: collapse;
        border-radius: 12px;
        overflow: hidden;
        box-shadow: inset 0 0 0 1px var(--border);
        background: var(--surface);
      }

      th,
      td {
        padding: 10px 14px;
        border-bottom: 1px solid var(--border);
        font-size: 13px;
        text-align: left;
      }

      th {
        background: #f1f4f9;
        font-weight: 600;
      }

      tr:last-child td {
        border-bottom: none;
      }

      .empty-placeholder {
        padding: 18px;
        border-radius: 12px;
        background: #f8f9fb;
        color: var(--muted);
        font-size: 13px;
      }

      .loading-overlay {
        position: fixed;
        inset: 0;
        background: rgba(255, 255, 255, 0.6);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 1000;
      }

      .loading-overlay.visible {
        display: flex;
      }

      .spinner {
        width: 48px;
        height: 48px;
        border-radius: 50%;
        border: 4px solid rgba(26, 115, 232, 0.15);
        border-top-color: var(--primary);
        animation: spin 1s linear infinite;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }

      .toast {
        position: fixed;
        right: 24px;
        top: 24px;
        padding: 14px 18px;
        background: rgba(32, 33, 36, 0.9);
        color: #fff;
        border-radius: 10px;
        font-size: 13px;
        display: none;
        z-index: 1100;
      }

      .toast.visible {
        display: block;
      }

      @media (max-width: 720px) {
        .region-controls {
          grid-template-columns: 1fr;
        }
        .tabs {
          overflow-x: auto;
        }
        .tab-button {
          white-space: nowrap;
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>地域別ダッシュボード</h1>
        <p class="description">
          都道府県・市区町村を切り替えて、Phase1 / 2 / 3 / 7 / 8 / 10 の主要指標と品質情報を横断的に確認できます。
        </p>
      </header>

      <section class="region-controls">
        <div class="field">
          <label for="prefectureSelect">都道府県</label>
          <select id="prefectureSelect" disabled>
            <option value="">読み込み中...</option>
          </select>
        </div>
        <div class="field">
          <label for="municipalitySelect">市区町村</label>
          <select id="municipalitySelect" disabled>
            <option value="">都道府県を選択してください</option>
          </select>
        </div>
        <button class="primary" id="refreshButton" disabled>最新データを取得</button>
      </section>

      <nav class="tabs" id="phaseTabs"></nav>

      <section class="panel">
        <div class="filters" id="filterPanel"></div>
        <div class="summary-grid" id="summaryGrid"></div>
        <div class="warnings" id="warningsBox">
          <div class="warning-title">⚠︎ 注意事項</div>
          <div class="warning-list" id="warningList"></div>
        </div>
        <div id="tablesContainer"></div>
      </section>
    </div>

    <div class="loading-overlay" id="loadingOverlay">
      <div class="spinner"></div>
    </div>
    <div class="toast" id="toast"></div>

    <script>
      const PHASE_CONFIG = [
        {
          id: "phase1",
          label: "Phase 1 基礎集計",
          fetch: "fetchPhase1Metrics",
          hasFilters: false,
          summaryLabels: {
            applicantCount: "応募者数",
            mapRecords: "MapMetrics 行数",
            aggDesiredRecords: "AggDesired 行数"
          }
        },
        {
          id: "phase2",
          label: "Phase 2 統計解析",
          fetch: "fetchPhase2Stats",
          hasFilters: false,
          summaryLabels: {
            chiSquareTests: "カイ二乗検定",
            anovaTests: "ANOVA検定"
          }
        },
        {
          id: "phase3",
          label: "Phase 3 ペルソナ分析",
          fetch: "fetchPhase3Persona",
          hasFilters: true,
          summaryLabels: {
            personaSegments: "セグメント数",
            averageDifficultyScore: "平均難易度スコア",
            topDifficultyLevel: "最難ランク"
          }
        },
        {
          id: "phase7",
          label: "Phase 7 高度分析",
          fetch: "fetchPhase7Supply",
          hasFilters: false,
          summaryLabels: {
            supplyRecords: "供給密度レコード",
            qualificationRecords: "資格分布レコード",
            mobilityRecords: "移動許容度レコード"
          }
        },
        {
          id: "phase8",
          label: "Phase 8 学歴・キャリア",
          fetch: "fetchPhase8Education",
          hasFilters: false,
          summaryLabels: {
            educationBuckets: "学歴種別",
            graduationBuckets: "卒業年分布"
          }
        },
        {
          id: "phase10",
          label: "Phase 10 転職意欲",
          fetch: "fetchPhase10Urgency",
          hasFilters: false,
          summaryLabels: {
            urgencyRecords: "緊急度分布",
            ageCrossRecords: "年齢クロス集計",
            employmentCrossRecords: "雇用形態クロス"
          }
        }
      ];

      const RESERVED_ALIAS_KEYS = new Set([
        "prefecture",
        "municipality",
        "regionKey",
        "latitude",
        "longitude",
        "count",
        "ratio",
        "score",
        "urgencyLevel",
        "urgencyScore",
        "segmentId",
        "segmentName"
      ]);

      const state = {
        region: {
          prefecture: null,
          municipality: null,
          key: null
        },
        municipalities: [],
        activePhase: "phase1",
        phaseCache: {},
        phase3Filters: {
          segmentId: "",
          difficultyLevel: ""
        }
      };

      const dom = {
        prefSelect: document.getElementById("prefectureSelect"),
        muniSelect: document.getElementById("municipalitySelect"),
        refreshButton: document.getElementById("refreshButton"),
        tabs: document.getElementById("phaseTabs"),
        filterPanel: document.getElementById("filterPanel"),
        summaryGrid: document.getElementById("summaryGrid"),
        warningsBox: document.getElementById("warningsBox"),
        warningList: document.getElementById("warningList"),
        tablesContainer: document.getElementById("tablesContainer"),
        loadingOverlay: document.getElementById("loadingOverlay"),
        toast: document.getElementById("toast")
      };

      function showToast(message, timeout = 3500) {
        dom.toast.textContent = message;
        dom.toast.classList.add("visible");
        setTimeout(() => dom.toast.classList.remove("visible"), timeout);
      }

      function setLoading(isLoading) {
        dom.loadingOverlay.classList.toggle("visible", isLoading);
        dom.refreshButton.disabled = isLoading;
        dom.prefSelect.disabled = isLoading;
        dom.muniSelect.disabled = isLoading;
      }

      function initialize() {
        setLoading(true);
        google.script.run
          .withSuccessHandler(handleInitialOptions)
          .withFailureHandler(handleError)
          .getRegionOptions();
      }

      function handleInitialOptions(payload) {
        state.region = payload.state || state.region;
        populatePrefectures(payload.prefectures || []);
        populateMunicipalities(payload.municipalities || []);
        renderTabs();
        registerEvents();
        setLoading(false);
        activatePhase(state.activePhase);
      }

      function populatePrefectures(prefectures) {
        const select = dom.prefSelect;
        select.innerHTML = "";

        if (!prefectures.length) {
          select.innerHTML = '<option value="">利用可能な都道府県が見つかりません</option>';
          select.disabled = true;
          return;
        }

        prefectures.forEach(pref => {
          const option = document.createElement("option");
          option.value = pref;
          option.textContent = pref;
          if (pref === state.region.prefecture) {
            option.selected = true;
          }
          select.append(option);
        });

        select.disabled = false;
      }

      function populateMunicipalities(municipalities) {
        state.municipalities = municipalities;
        const select = dom.muniSelect;
        select.innerHTML = "";

        const placeholder = document.createElement("option");
        placeholder.value = "";
        placeholder.textContent = municipalities.length ? "市区町村を選択（任意）" : "該当する市区町村がありません";
        select.append(placeholder);

        municipalities.forEach(muni => {
          const option = document.createElement("option");
          option.value = muni;
          option.textContent = muni;
          if (muni === state.region.municipality) {
            option.selected = true;
          }
          select.append(option);
        });

        select.disabled = false;
      }

      function renderTabs() {
        dom.tabs.innerHTML = "";
        PHASE_CONFIG.forEach(phase => {
          const button = document.createElement("button");
          button.type = "button";
          button.className = "tab-button" + (phase.id === state.activePhase ? " active" : "");
          button.textContent = phase.label;
          button.dataset.phase = phase.id;
          dom.tabs.append(button);
        });
      }

      function registerEvents() {
        dom.prefSelect.addEventListener("change", handlePrefectureChange);
        dom.muniSelect.addEventListener("change", handleMunicipalityChange);
        dom.refreshButton.addEventListener("click", () => refreshPhase(state.activePhase, { force: true }));
        dom.tabs.addEventListener("click", evt => {
          const target = evt.target.closest(".tab-button");
          if (!target) return;
          const phaseId = target.dataset.phase;
          activatePhase(phaseId);
        });
      }

      function handlePrefectureChange() {
        const selectedPref = dom.prefSelect.value || null;
        if (!selectedPref) {
          return;
        }

        setLoading(true);
        google.script.run
          .withSuccessHandler(municipalities => {
            populateMunicipalities(municipalities || []);
            const selectedMuni = municipalities.includes(state.region.municipality)
              ? state.region.municipality
              : municipalities[0] || null;
            saveRegion(selectedPref, selectedMuni, true);
          })
          .withFailureHandler(handleError)
          .getMunicipalitiesForPrefecture(selectedPref);
      }

      function handleMunicipalityChange() {
        const selectedMuni = dom.muniSelect.value || null;
        saveRegion(state.region.prefecture, selectedMuni, true);
      }

      function saveRegion(prefecture, municipality, refreshAfter = false) {
        setLoading(true);
        google.script.run
          .withSuccessHandler(updated => {
            state.region = updated;
            state.phaseCache = {};
            setLoading(false);
            if (refreshAfter) {
              refreshPhase(state.activePhase, { force: true });
            }
          })
          .withFailureHandler(handleError)
          .saveSelectedRegion(prefecture, municipality);
      }

      function activatePhase(phaseId) {
        if (!phaseId) return;
        state.activePhase = phaseId;
        Array.from(dom.tabs.querySelectorAll(".tab-button")).forEach(button => {
          button.classList.toggle("active", button.dataset.phase === phaseId);
        });
        refreshPhase(phaseId);
      }

      function refreshPhase(phaseId, options = {}) {
        const phase = PHASE_CONFIG.find(p => p.id === phaseId);
        if (!phase) return;

        const useCache = !options.force && state.phaseCache[phaseId];
        if (useCache) {
          renderPhaseData(phase, state.phaseCache[phaseId], { fromCache: true });
          return;
        }

        setLoading(true);
        const args = buildPhaseArgs(phaseId);

        let runner = google.script.run
          .withSuccessHandler(data => {
            state.phaseCache[phaseId] = data;
            renderPhaseData(phase, data, { fromCache: false });
            setLoading(false);
            if (!options.fromFilter && phaseId === "phase3") {
              updatePhase3Filters(data);
            }
          })
          .withFailureHandler(handleError);

        runner = runner[phase.fetch];
        runner.apply(null, args);
      }

      function buildPhaseArgs(phaseId) {
        const base = [state.region.prefecture, state.region.municipality];
        if (phaseId === "phase3") {
          return [
            ...base,
            {
              segmentId: state.phase3Filters.segmentId || "",
              difficultyLevel: state.phase3Filters.difficultyLevel || ""
            }
          ];
        }
        return base;
      }

      function renderPhaseData(phase, data, meta) {
        renderSummary(phase, data.summary || {});
        renderWarnings(data.warnings || []);
        renderTables(data.tables || {});
        renderFilters(phase, data);
        if (meta.fromCache) {
          showToast("キャッシュされた結果を表示中（最新データが必要な場合は更新してください）", 2500);
        }
      }

      function renderSummary(phase, summary) {
        dom.summaryGrid.innerHTML = "";
        const labels = phase.summaryLabels || {};
        const entries = Object.entries(summary || {});

        if (!entries.length) {
          const placeholder = document.createElement("div");
          placeholder.className = "empty-placeholder";
          placeholder.textContent = "このフェーズでは表示可能なサマリー指標がありません。";
          dom.summaryGrid.append(placeholder);
          return;
        }

        entries.forEach(([key, value]) => {
          const card = document.createElement("div");
          card.className = "summary-card";

          const label = document.createElement("div");
          label.className = "label";
          label.textContent = labels[key] || key;

          const val = document.createElement("div");
          val.className = "value";
          val.textContent = formatValue(value);

          card.append(label, val);
          dom.summaryGrid.append(card);
        });
      }

      function renderWarnings(warnings) {
        if (!warnings || !warnings.length) {
          dom.warningsBox.classList.remove("visible");
          dom.warningList.innerHTML = "";
          return;
        }

        dom.warningsBox.classList.add("visible");
        dom.warningList.innerHTML = "";
        warnings.forEach(message => {
          const row = document.createElement("div");
          row.textContent = message;
          dom.warningList.append(row);
        });
      }

      function renderTables(tables) {
        dom.tablesContainer.innerHTML = "";
        const entries = Object.entries(tables || {});
        if (!entries.length) {
          const placeholder = document.createElement("div");
          placeholder.className = "empty-placeholder";
          placeholder.textContent = "表示できるテーブルがありません。";
          dom.tablesContainer.append(placeholder);
          return;
        }

        entries.forEach(([tableKey, rows]) => {
          const group = document.createElement("section");
          group.className = "table-group";

          const title = document.createElement("div");
          title.className = "table-title";
          title.textContent = deriveTableTitle(tableKey);

          group.append(title);
          if (!Array.isArray(rows) || !rows.length) {
            const placeholder = document.createElement("div");
            placeholder.className = "empty-placeholder";
            placeholder.textContent = "該当データがありません。";
            group.append(placeholder);
          } else {
            const sanitized = sanitizeRecords(rows);
            const table = buildTableElement(sanitized);
            group.append(table);
          }
          dom.tablesContainer.append(group);
        });
      }

      function deriveTableTitle(key) {
        const map = {
          mapMetrics: "MapMetrics",
          aggDesired: "AggDesired",
          quality: "品質レポート",
          chiSquare: "ChiSquareTests",
          anova: "ANOVATests",
          personaSummary: "PersonaSummary",
          personaDetails: "PersonaDetails",
          supplyDensity: "SupplyDensityMap",
          qualificationDistribution: "QualificationDistribution",
          ageGenderCross: "AgeGenderCrossAnalysis",
          mobilityScore: "MobilityScore",
          personaProfile: "DetailedPersonaProfile",
          educationDistribution: "EducationDistribution",
          educationCross: "EducationAgeCross",
          graduationDistribution: "GraduationYearDistribution",
          urgencyDistribution: "UrgencyDistribution",
          ageCross: "UrgencyAgeCross",
          employmentCross: "UrgencyEmploymentCross",
          desiredWorkCross: "UrgencyDesiredWorkCross"
        };
        return map[key] || key;
      }

      function sanitizeRecords(records) {
        return records.map(record => {
          const cleaned = {};
          Object.keys(record).forEach(key => {
            if (key === "__normalized") return;
            if (RESERVED_ALIAS_KEYS.has(key)) return;
            cleaned[key] = record[key];
          });
          if (!Object.keys(cleaned).length) {
            Object.keys(record).forEach(key => {
              if (key !== "__normalized" && !cleaned.hasOwnProperty(key)) {
                cleaned[key] = record[key];
              }
            });
          }
          return cleaned;
        });
      }

      function buildTableElement(records) {
        const table = document.createElement("table");
        const thead = document.createElement("thead");
        const tbody = document.createElement("tbody");

        const columns = deriveColumns(records);
        const headerRow = document.createElement("tr");
        columns.forEach(col => {
          const th = document.createElement("th");
          th.textContent = col;
          headerRow.append(th);
        });
        thead.append(headerRow);

        records.forEach(record => {
          const row = document.createElement("tr");
          columns.forEach(col => {
            const td = document.createElement("td");
            td.textContent = formatValue(record[col]);
            row.append(td);
          });
          tbody.append(row);
        });

        table.append(thead, tbody);
        return table;
      }

      function deriveColumns(records) {
        if (!records.length) return [];
        const ordered = Object.keys(records[0]);
        const seen = new Set();
        return ordered.filter(col => {
          if (seen.has(col)) return false;
          seen.add(col);
          return true;
        });
      }

      function formatValue(value) {
        if (value === null || value === undefined || value === "") {
          return "-";
        }
        if (typeof value === "number") {
          return Number.isInteger(value) ? value.toLocaleString("ja-JP") : Number(value).toLocaleString("ja-JP", { maximumFractionDigits: 3 });
        }
        if (typeof value === "boolean") {
          return value ? "はい" : "いいえ";
        }
        return String(value);
      }

      function renderFilters(phase, data) {
        if (!phase.hasFilters) {
          dom.filterPanel.classList.remove("active");
          dom.filterPanel.innerHTML = "";
          return;
        }

        dom.filterPanel.classList.add("active");
        dom.filterPanel.innerHTML = "";

        if (phase.id === "phase3") {
          const { personaSummary = [] } = data.tables || {};
          const segmentOptions = personaSummary
            .map(record => {
              const id = record.segment_id ?? record.segmentId;
              const name = record.segment_name ?? record.segmentName ?? id;
              if (id === undefined || id === null || id === "") return null;
              return { id: String(id), name: String(name) };
            })
            .filter(Boolean);

          const difficultyOptions = personaSummary
            .map(record => record.difficulty_level ?? record.difficultyLevel)
            .filter(level => level && level !== "");

          const uniqueSegments = [];
          const seenSegments = new Set();
          segmentOptions.forEach(option => {
            if (seenSegments.has(option.id)) return;
            seenSegments.add(option.id);
            uniqueSegments.push(option);
          });

          const uniqueDifficulties = Array.from(new Set(difficultyOptions));

          const segmentWrapper = document.createElement("div");
          segmentWrapper.className = "field";

          const segmentLabel = document.createElement("label");
          segmentLabel.textContent = "ペルソナ セグメント";
          segmentLabel.htmlFor = "segmentFilter";

          const segmentSelect = document.createElement("select");
          segmentSelect.id = "segmentFilter";
          segmentSelect.innerHTML = '<option value="">全セグメント</option>';

          uniqueSegments.forEach(option => {
            const opt = document.createElement("option");
            opt.value = option.id;
            opt.textContent = `${option.id}: ${option.name}`;
            if (option.id === state.phase3Filters.segmentId) {
              opt.selected = true;
            }
            segmentSelect.append(opt);
          });

          segmentSelect.addEventListener("change", () => {
            state.phase3Filters.segmentId = segmentSelect.value;
            state.phaseCache.phase3 = null;
            refreshPhase("phase3", { force: true, fromFilter: true });
          });

          segmentWrapper.append(segmentLabel, segmentSelect);
          dom.filterPanel.append(segmentWrapper);

          const difficultyWrapper = document.createElement("div");
          difficultyWrapper.className = "field";

          const difficultyLabel = document.createElement("label");
          difficultyLabel.textContent = "難易度ランク";
          difficultyLabel.htmlFor = "difficultyFilter";

          const difficultySelect = document.createElement("select");
          difficultySelect.id = "difficultyFilter";
          difficultySelect.innerHTML = '<option value="">全ランク</option>';

          uniqueDifficulties.forEach(level => {
            const opt = document.createElement("option");
            opt.value = level;
            opt.textContent = level;
            if (level === state.phase3Filters.difficultyLevel) {
              opt.selected = true;
            }
            difficultySelect.append(opt);
          });

          difficultySelect.addEventListener("change", () => {
            state.phase3Filters.difficultyLevel = difficultySelect.value;
            state.phaseCache.phase3 = null;
            refreshPhase("phase3", { force: true, fromFilter: true });
          });

          difficultyWrapper.append(difficultyLabel, difficultySelect);
          dom.filterPanel.append(difficultyWrapper);
        }
      }

      function updatePhase3Filters(data) {
        if (state.activePhase !== "phase3") return;
        renderFilters(PHASE_CONFIG.find(p => p.id === "phase3"), data);
      }

      function handleError(error) {
        setLoading(false);
        console.error(error);
        const message = error && error.message ? error.message : "不明なエラーが発生しました。";
        showToast(message);
      }

      document.addEventListener("DOMContentLoaded", initialize);
    </script>
  </body>
</html>
